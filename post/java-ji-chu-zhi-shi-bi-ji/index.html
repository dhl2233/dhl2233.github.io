<html>
<head>
    <meta charset="utf-8" />
<meta name="description" content="" />
<meta name="viewport" content="width=device-width, initial-scale=1" />

<title>Java基础知识 | 刘冬辉的个人博客</title>

<link rel="shortcut icon" href="https://dhl2233.github.io/favicon.ico?v=1716159646223">

<link href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" rel="stylesheet">
<link rel="stylesheet" href="https://dhl2233.github.io/styles/main.css">
<!-- <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.5.0/dist/css/bootstrap.min.css"> -->

<script src="https://cdn.jsdelivr.net/npm/@highlightjs/cdn-assets/highlight.min.js"></script>
<script src="https://cdn.bootcdn.net/ajax/libs/highlight.js/9.12.0/languages/dockerfile.min.js"></script>
<script src="https://cdn.bootcdn.net/ajax/libs/highlight.js/9.12.0/languages//dart.min.js"></script>

<!-- <script src="https://cdn.jsdelivr.net/npm/moment@2.27.0/moment.min.js"></script> -->
<!-- <script src="https://cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.slim.min.js"></script> -->
<!-- <script src="https://cdn.jsdelivr.net/npm/popper.js@1.16.0/dist/umd/popper.min.js"></script> -->
<!-- <script src="https://cdn.jsdelivr.net/npm/bootstrap@4.5.0/dist/js/bootstrap.min.js"></script> -->
<!-- DEMO JS -->
<!--<script src="media/scripts/index.js"></script>-->



    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.css">
    
</head>
<body>
<div class="main gt-bg-theme-color-first">
    <nav class="navbar navbar-expand-lg">
    <a class="navbar-brand" href="/">
        <img class="user-avatar" src="/images/avatar.png" alt="头像">
        <div class="site-name gt-c-content-color-first">
            刘冬辉的个人博客
        </div>
    </a>
    <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent"
        aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation" id="changeNavbar">
        <i class="fas fa-bars gt-c-content-color-first" style="font-size: 18px"></i>
    </button>
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
        <div class="navbar-nav mr-auto" style="text-align: center">
            
            <div class="nav-item">
                
                <a href="/" class="menu gt-a-link">
                    首页
                </a>
                
            </div>
            
            <div class="nav-item">
                
                <a href="/archives" class="menu gt-a-link">
                    归档
                </a>
                
            </div>
            
        </div>
        <div style="text-align: center">
            <form id="gridea-search-form" style="position: relative" data-update="1716159646223"
                action="/search/">
                <input class="search-input" autocomplete="off" spellcheck="false" name="q" placeholder="搜索文章" />
                <i class="fas fa-search gt-c-content-color-first" style="position: absolute; top: 9px; left: 10px;"></i>
            </form>
        </div>
    </div>
</nav>
<script>
    /* 移动端导航栏展开/收起切换 */
    document.getElementById('changeNavbar').onclick = () => {
        var element = document.getElementById('navbarSupportedContent');
        if (element.style.display === 'none' || element.style.display === '') {
            element.style.display = 'block';
        } else {
            element.style.display = 'none';
        }
    }
</script>

    <div class="post-container">
        <div class="post-detail gt-bg-theme-color-second">
            <article class="gt-post-content">
                <h2 class="post-title">
                    Java基础知识
                </h2>
                <div class="post-info">
                    <time class="post-time gt-c-content-color-first">
                        · 2023-10-01 ·
                    </time>
                    
                </div>
                <div class="post-content">
                    <h2 id="面相对象三要素">面相对象三要素</h2>
<ul>
<li>封装是把过程和数据包围起来，对数据的访问只能通过已定义的界面。面向对象计算始于这个基本概念，即现实世界可以被描绘成一系列完全自治、封装的对象，这些对象通过一个受保护的接口访问其他对象。</li>
<li>继承是一种联结类的层次模型，它提供了一种明确表述共性的方法。新类可以从现有的类中派生，新类继承了原始类的特性，新类称为原始类的派生类（子类），原始类称为新类的基类（父类或超类）。</li>
<li>多态性是指允许不同的类的对象对同一消息作出响应。多态性语言具有灵活、抽象、行为共享、代码共享的优势，很好的解决了应用程序函数重名问题。</li>
</ul>
<h2 id="第一个-java-程序">第一个 JAVA 程序</h2>
<p><code>public class HelloWorld {     public static void main(String[] args) {         System.out.println(&quot;Hello World&quot;);     } }</code></p>
<h1 id="基本数据类型">基本数据类型</h1>
<pre><code class="language-java">        //byte - 字节型，占用 1 个字节，范围从 -128 到 127。
        byte a = 100;
        //short - 短整型，占用 2 个字节，范围从 -32,768 到 32,767。
        short b = 5000;
        //int - 整型，占用 4 个字节，范围从 -2^31 到 2^31-1。
        int c = 123456;
        //long - 长整型，占用 8 个字节，范围从 -2^63 到 2^63-1。
        long d = 12345678901L;
        //float - 单精度浮点型，占用 4 个字节。
        float e = 5.75f;
        //double - 双精度浮点型，占用 8 个字节。
        double f = 19.99;
        //char - 字符型，占用 2 个字节，用于存储单个字符（如字母和 ASCII 值）。
        char g = 'A';
        //boolean - 布尔型，占用 1 位，表示 true 或 false。
        boolean h = true;
</code></pre>
<h2 id="变量类型">变量类型</h2>
<p>**局部变量（Local Variables）：**局部变量是在方法、构造函数或块内部声明的变量，它们在声明的方法、构造函数或块执行结束后被销毁，局部变量在声明时需要初始化，否则会导致编译错误。</p>
<p>**实例变量（Instance Variables）：**实例变量是在类中声明，但在方法、构造函数或块之外，它们属于类的实例，每个类的实例都有自己的副本，如果不明确初始化，实例变量会被赋予默认值（数值类型为0，boolean类型为false，对象引用类型为null）。</p>
<p>**静态变量或类变量（Class Variables）：**类变量是在类中用 static 关键字声明的变量，它们属于类而不是实例，所有该类的实例共享同一个类变量的值，类变量在类加载时被初始化，而且只初始化一次。</p>
<p>**参数变量（Parameters）：**参数是方法或构造函数声明中的变量，用于接收调用该方法或构造函数时传递的值，参数变量的作用域只限于方法内部。</p>
<ul>
<li>**值传递：**在方法调用时，传递的是实际参数的值的副本。当参数变量被赋予新的值时，只会修改副本的值，不会影响原始值。Java 中的基本数据类型都采用值传递方式传递参数变量的值。</li>
<li>**引用传递：**在方法调用时，传递的是实际参数的引用（即内存地址）。当参数变量被赋予新的值时，会修改原始值的内容。Java 中的对象类型采用引用传递方式传递参数变量的值。</li>
</ul>
<h1 id="java-变量命名规则">Java 变量命名规则</h1>
<p>在 Java 中，不同类型的变量（例如实例变量、局部变量、静态变量等）有一些命名规则和约定。</p>
<p>遵循一些基本规则，这有助于提高代码的可读性和维护性。</p>
<p>以下是各种变量命名规则的概述：</p>
<ul>
<li><strong>使用有意义的名字：</strong> 变量名应该具有清晰的含义，能够准确地反映变量的用途。避免使用单个字符或无意义的缩写。</li>
<li><strong>驼峰命名法（Camel Case）：</strong> 在变量名中使用驼峰命名法，即将每个单词的首字母大写，除了第一个单词外，其余单词的首字母都采用大写形式。例如：<code>myVariableName</code>。</li>
<li><strong>避免关键字：</strong> 不要使用 Java 关键字（例如，class、int、boolean等）作为变量名。</li>
<li><strong>区分大小写：</strong> Java 是大小写敏感的，因此变量名中的大小写字母被视为不同的符号。例如，<code>myVariable</code> 和 <code>myvariable</code> 是两个不同的变量。</li>
<li><strong>不以数字开头：</strong> 变量名不能以数字开头，但可以包含数字。</li>
<li><strong>遵循命名约定：</strong> 对于不同类型的变量（局部变量、实例变量、静态变量等），可以采用不同的命名约定，例如使用前缀或后缀来区分。</li>
</ul>
<h3 id="静态变量类变量">静态变量（类变量）</h3>
<ul>
<li>使用驼峰命名法，应该以小写字母开头。</li>
<li>通常也可以使用大写蛇形命名法，全大写字母，单词之间用下划线分隔。</li>
<li>变量名应该是描述性的，能够清晰地表示其用途。</li>
</ul>
<p><code>// 使用驼峰命名法</code><br>
<code>public static int myStaticVariable;</code></p>
<p><code>// 使用大写蛇形命名法</code><br>
<code>public static final int MAX_SIZE = 100;</code></p>
<h1 id="java-修饰符">Java 修饰符</h1>
<h2 id="访问控制修饰符">访问控制修饰符</h2>
<p>Java中，可以使用访问控制符来保护对类、变量、方法和构造方法的访问。Java 支持 4 种不同的访问权限。</p>
<ul>
<li><strong>default</strong> (即默认，什么也不写）: 在同一包内可见，不使用任何修饰符。使用对象：类、接口、变量、方法。</li>
<li><strong>private</strong> : 在同一类内可见。使用对象：变量、方法。 <strong>注意：不能修饰类（外部类）</strong></li>
<li><strong>public</strong> : 对所有类可见。使用对象：类、接口、变量、方法</li>
<li><strong>protected</strong> : 对同一包内的类和所有子类可见。使用对象：变量、方法。 <strong>注意：不能修饰类（外部类）</strong>。<br>
<img src="https://dhl2233.github.io/post-images/1715155425703.png" alt="" loading="lazy"></li>
</ul>
<h3 id="static-修饰符">static 修饰符</h3>
<ul>
<li>
<p><strong>静态变量：</strong></p>
<p>static 关键字用来声明独立于对象的静态变量，无论一个类实例化多少对象，它的静态变量只有一份拷贝。 静态变量也被称为类变量。局部变量不能被声明为 static 变量。</p>
</li>
<li>
<p><strong>静态方法：</strong></p>
<p>static 关键字用来声明独立于对象的静态方法。静态方法不能使用类的非静态变量。静态方法从参数列表得到数据，然后计算这些数据。</p>
</li>
</ul>
<h3 id="final-修饰符">final 修饰符</h3>
<p><strong>final 变量：</strong></p>
<p>final 表示&quot;最后的、最终的&quot;含义，变量一旦赋值后，不能被重新赋值。被 final 修饰的实例变量必须显式指定初始值。</p>
<p>final 修饰符通常和 static 修饰符一起使用来创建类常量。</p>
<p><strong>final 方法</strong></p>
<p>父类中的 final 方法可以被子类继承，但是不能被子类重写。</p>
<p>声明 final 方法的主要目的是防止该方法的内容被修改。</p>
<p><strong>final 类</strong></p>
<p>final 类不能被继承，没有类能够继承 final 类的任何特性。</p>
<h3 id="abstract-修饰符">abstract 修饰符</h3>
<p><strong>抽象类：</strong></p>
<p>抽象类不能用来实例化对象，声明抽象类的唯一目的是为了将来对该类进行扩充。</p>
<p>一个类不能同时被 abstract 和 final 修饰。如果一个类包含抽象方法，那么该类一定要声明为抽象类，否则将出现编译错误。</p>
<p>抽象类可以包含抽象方法和非抽象方法。</p>
<p><strong>抽象方法</strong></p>
<p>抽象方法是一种没有任何实现的方法，该方法的具体实现由子类提供。</p>
<p>抽象方法不能被声明成 final 和 static。</p>
<p>任何继承抽象类的子类必须实现父类的所有抽象方法，除非该子类也是抽象类。</p>
<p>如果一个类包含若干个抽象方法，那么该类必须声明为抽象类。抽象类可以不包含抽象方法。</p>
<h1 id="java-string-stringbuffer-和-stringbuilder-类">Java String、StringBuffer 和 StringBuilder 类</h1>
<p>String 类是不可改变的，所以你一旦创建了 String 对象，那它的值就无法改变了</p>
<p>和 String 类不同的是，StringBuffer 和 StringBuilder 类的对象能够被多次的修改，并且不产生新的未使用对象。</p>
<p>StringBuffer是线程安全的，它的所有公开方法都是通过内部的synchronized修饰来实现同步的，从而保证了多线程环境下的数据一致性。因此，在多线程环境下，如果有多个线程同时访问和修改同一个StringBuffer对象，不会出现数据不一致的问题。</p>
<p>与StringBuffer不同，StringBuilder并没有使用synchronized修饰其方法，因此它是线程不安全的。在单线程环境下，StringBuilder的性能要优于StringBuffer，因为它避免了不必要的同步开销。但是，在多线程环境下，如果多个线程同时访问和修改同一个StringBuilder对象，就可能导致数据不一致的问题。</p>
<h1 id="java-异常处理">Java 异常处理</h1>
<p>**检查性异常：**最具代表的检查性异常是用户错误或问题引起的异常，这些异常在编译时强制要求程序员处理。例如要打开一个不存在文件时，一个异常就发生了，这些异常在编译时不能被简单地忽略。</p>
<p>这类异常通常使用 <strong>try-catch</strong> 块来捕获并处理异常，或者在方法声明中使用 <strong>throws</strong> 子句声明方法可能抛出的异常。</p>
<p><strong>运行时异常：</strong> 些异常在编译时不强制要求处理，通常是由程序中的错误引起的，例如 NullPointerException、ArrayIndexOutOfBoundsException 等，这类异常可以选择处理，但并非强制要求。</p>
<p><strong>错误：</strong> 错误不是异常，而是脱离程序员控制的问题，错误在代码中通常被忽略。例如，当栈溢出时，一个错误就发生了，它们在编译也检查不到的。</p>
<p>Java 提供了以下关键字和类来支持异常处理：</p>
<ul>
<li><strong>try</strong>：用于包裹可能会抛出异常的代码块。</li>
<li><strong>catch</strong>：用于捕获异常并处理异常的代码块。</li>
<li><strong>finally</strong>：用于包含无论是否发生异常都需要执行的代码块。</li>
<li><strong>throw</strong>：用于手动抛出异常。</li>
<li><strong>throws</strong>：用于在方法声明中指定方法可能抛出的异常。</li>
<li><strong>Exception</strong>类：是所有异常类的父类，它提供了一些方法来获取异常信息，如 <strong>getMessage()、printStackTrace()</strong> 等。</li>
</ul>
<h2 id="exception-类的层次">Exception 类的层次</h2>
<p>所有的异常类是从 java.lang.Exception 类继承的子类。</p>
<p>Exception 类是 Throwable 类的子类。除了Exception类外，Throwable还有一个子类Error 。</p>
<p>Java 程序通常不捕获错误。错误一般发生在严重故障时，它们在Java程序处理的范畴之外。</p>
<p>Error 用来指示运行时环境发生的错误。</p>
<p>例如，JVM 内存溢出。一般地，程序不会从错误中恢复。</p>
<p>异常类有两个主要的子类：IOException 类和 RuntimeException 类。</p>
<h1 id="java-集合框架">Java 集合框架</h1>
<figure data-type="image" tabindex="1"><img src="https://dhl2233.github.io/post-images/1715155434178.png" alt="" loading="lazy"></figure>
<h2 id="如何使用迭代器">如何使用迭代器</h2>
<p>通常情况下，你会希望遍历一个集合中的元素。例如，显示集合中的每个元素。</p>
<p>一般遍历数组都是采用for循环或者增强for，这两个方法也可以用在集合框架，但是还有一种方法是采用迭代器遍历集合框架，它是一个对象，实现了<a href="https://www.runoob.com/java/java-iterator.html">Iterator</a> 接口或 ListIterator接口。</p>
<p>迭代器，使你能够通过循环来得到或删除集合的元素。ListIterator 继承了 Iterator，以允许双向遍历列表和修改元素。</p>
<h3 id="使用迭代器遍历-arraylist">使用迭代器遍历 ArrayList</h3>
<pre><code>public static void main(String[] args) {
    // 创建一个 ArrayList
    ArrayList&lt;String&gt; names = new ArrayList&lt;&gt;();
    names.add(&quot;Alice&quot;);
    names.add(&quot;Bob&quot;);
    names.add(&quot;Charlie&quot;);

    // 获取迭代器
    Iterator&lt;String&gt; it = names.iterator();

    // 使用迭代器遍历 ArrayList
    while (it.hasNext()) {
        String name = it.next();
        System.out.println(name);
    }
}
</code></pre>
<h3 id="在遍历时删除元素">在遍历时删除元素</h3>
<pre><code>public static void main(String[] args) {
    // 创建一个 ArrayList
    ArrayList&lt;Integer&gt; numbers = new ArrayList&lt;&gt;();
    numbers.add(1);
    numbers.add(2);
    numbers.add(3);
    numbers.add(4);
    numbers.add(5);

    // 获取迭代器
    Iterator&lt;Integer&gt; it = numbers.iterator();

    // 遍历并删除偶数
    while (it.hasNext()) {
        Integer number = it.next();
        if (number % 2 == 0) {
            it.remove(); // 删除当前元素
        }
    }

    // 再次使用迭代器输出剩余元素
    it = numbers.iterator();
    while (it.hasNext()) {
        System.out.println(it.next());
    }
}
</code></pre>
<h3 id="使用-listiterator-遍历-list">使用 ListIterator 遍历 List</h3>
<pre><code>public static void main(String[] args) {
    // 创建一个 LinkedList
    LinkedList&lt;String&gt; names = new LinkedList&lt;&gt;();
    names.add(&quot;Alice&quot;);
    names.add(&quot;Bob&quot;);
    names.add(&quot;Charlie&quot;);

    // 获取 ListIterator
    ListIterator&lt;String&gt; listIt = names.listIterator();

    // 正向遍历列表
    System.out.println(&quot;Forward traversal:&quot;);
    while (listIt.hasNext()) {
        System.out.println(listIt.next());
    }

    // 反向遍历列表
    System.out.println(&quot;Backward traversal:&quot;);
    while (listIt.hasPrevious()) {
        System.out.println(listIt.previous());
    }
}
</code></pre>

                </div>
            </article>
        </div>

        
            <div class="next-post">
                <div class="next gt-c-content-color-first">下一篇</div>
                <a href="https://dhl2233.github.io/post/shi-yong-java-swing-shi-xian-yi-ge-e-luo-si-fang-kuai/" class="post-title gt-a-link">
                    使用Java Swing实现一个俄罗斯方块
                </a>
            </div>
        

        

        

        

        <div class="site-footer gt-c-content-color-first">
    <div class="slogan gt-c-content-color-first">日日行能走千里路，时时学能破万卷书</div>
    <div class="social-container">
        
            
        
            
        
            
        
            
        
            
        
            
        
    </div>
    <div class="footer-info">
        Design by 刘冬辉<a href="https://github.com/dhl2233" target="_blank">个人github</a>
    </div>
    <div>
        Theme <a href="https://github.com/imhanjie/gridea-theme-pure" target="_blank">Pure</a>, Powered by <a
                href="https://gridea.dev" target="_blank">Gridea</a> | <a href="https://dhl2233.github.io/atom.xml" target="_blank">RSS</a>
    </div>
</div>

<script>
  hljs.highlightAll()
</script>

    </div>
</div>
</body>
</html>
